#!/usr/bin/env ys-0

# Harbor Helm Migration Tool - YAMLScript Implementation
# Usage: ys harbor-migrate.ys <input-values.yaml> [output-values.yaml]

defn main(input-file output-file=nil):
  legacy =: input-file:read:yaml/load
  check-unsupported: legacy
  storage-result =: legacy:map-storage
  redis-result =: legacy:map-redis

  result =: !remove-nils
    merge map-direct-fields(legacy) redis-result::
      ingress:: map-ingress(legacy)
      database:: map-database(legacy)
      core:: map-core(legacy)
      portal:: map-portal(legacy)
      registry:: map-registry(legacy) + storage-result
      jobservice:: map-jobservice(legacy)
      exporter:: map-exporter(legacy)
      trivy:: map-trivy(legacy)
      metrics:: map-metrics(legacy)

  print-warnings:

  if output-file:
    then:
      warn: "\nMigrated values written to: $output-file"
      write output-file: result:yaml/dump
    else:
      say: result:yaml/dump

defn map-direct-fields(legacy)::
  externalURL:: legacy.externalURL
  harborAdminPassword:: legacy.harborAdminPassword
  secretKey:: legacy.secretKey
  logLevel:: legacy.logLevel
  image:
    pullPolicy:: legacy.imagePullPolicy || 'IfNotPresent'

defn map-ingress(legacy):
  expose-type =: legacy.expose.type || 'ingress'
  host =: legacy.expose.ingress.hosts.core
  tls-enabled =: legacy.expose.tls.enabled
  cert-source =: legacy.expose.tls.certSource

  when expose-type != 'ingress':
    add-warn 'ERROR' 'expose.type': +
      "expose.type='$expose-type is not supported."
      'Migrate to ingress'

  when tls-enabled && cert-source.eq('auto'):
    add-warn: +
      'WARNING'
      'expose.tls.certSource'
      "certSource='auto' is not supported."
      'Configure tls.certManager'

  =>::
    enabled:: true
    className:: legacy.expose.ingress.className
    annotations:: legacy.expose.ingress.annotations
    hosts:
    - host:: host
      paths:
      - path: /
        pathType: Prefix
    tls::
      if tls-enabled && cert-source.eq('secret'):
        then::
          secretName:: legacy.expose.tls.secret.secretName
          hosts: [! host]
        else:: []

defn map-storage(legacy):
  storage-type =: legacy.persistence.imageChartStorage.type || 'filesystem'

  storage =:
    cond:
      storage-type == "filesystem"::
        filesystem:
          rootdirectory:: legacy.persistence.imageChartStorage.filesystem.rootdirectory ||
            '/storage'
        type: filesystem
      storage-type == "s3"::
        type: s3
        s3:: legacy.persistence.imageChartStorage.s3
      else:
        type:: storage-type

  pvc =: legacy.persistence.persistentVolumeClaim.registry
  pvc-size =: pvc.size || '50Gi'
  access-mode =: pvc.accessMode

  persistence =::
    enabled:: legacy.persistence.enabled || true
    accessModes::
      when access-mode:: [! access-mode]
    storageClass:: pvc.storageClass
    size:: pvc-size
    existingClaim:: pvc.existingClaim

  =>:: {storage:: storage, persistence:: persistence}

warnings =: atom([])

defn add-warn(level path msg action):
  swap warnings conj::
    level:: level
    path:: path
    message:: msg
    action:: action

# This function will go away in the end:
defn get-or(m keys default):
  m.get-in(keys) || default

#------------------------------------------------------------------------------
# Unrefactored code below:
#------------------------------------------------------------------------------
defn map-database(legacy):
  db-type =: get-or(legacy ["database" "type"] "internal")

  if (db-type == "internal"):
    then:
      add-warn "ERROR" "database.type" "Internal database is not supported." "Deploy external PostgreSQL":
      =>: hash-map()
    else:
      ext =: get-in(legacy ["database" "external"])
      port-str =: get-or(ext ["port"] "5432")
      port =: or((parse-long port-str) 5432)
      =>: hash-map("host" (get ext "host") "port" port "username" (get-or ext ["username"] "postgres") "password" (get ext "password") "database" (get-or ext ["coreDatabase"] "registry") "sslmode" (get-or ext ["sslmode"] "disable"))

defn map-redis(legacy):
  redis-type =: get-or(legacy ["redis" "type"] "internal")

  if (redis-type == "internal"):
    then:
      add-warn "INFO" "redis.type" "Internal Redis migrated to Valkey subchart" "Review valkey.* settings":
      =>: hash-map("valkey" (hash-map "enabled" true "architecture" "standalone" "auth" (hash-map "enabled" true)) "externalRedis" (hash-map))
    else:
      ext =: get-in(legacy ["redis" "external"])
      addr =: get(ext "addr")
      parts =: (if addr (str/split addr ":") [])
      host =: first(parts)
      port-str =: (if (> (count parts) 1) (second parts) "6379")
      port =: or((parse-long port-str) 6379)
      =>: hash-map("valkey" (hash-map "enabled" false) "externalRedis" (hash-map "host" host "port" port "password" (get ext "password")))

defn map-image(img):
  =>: hash-map("repository" (get img "repository") "tag" (get img "tag"))

defn map-component-base(comp):
  img =: get(comp "image")
  =>: hash-map("image" (if img (map-image img) nil) "replicas" (get comp "replicas") "resources" (get comp "resources") "nodeSelector" (get comp "nodeSelector") "tolerations" (get comp "tolerations") "affinity" (get comp "affinity") "podAnnotations" (get comp "podAnnotations") "podLabels" (get comp "podLabels") "extraEnv" (get comp "extraEnvVars"))

defn map-core(legacy):
  core =: get(legacy "core")
  base =: map-component-base(core)
  secret =: (if (or (get core "secret") (get core "xsrfKey")) (hash-map "secret" (get core "secret") "csrf_key" (get core "xsrfKey")) nil)
  config =: (if (get core "quotaUpdateProvider") (hash-map "quota" (hash-map "update_provider" (get core "quotaUpdateProvider"))) nil)
  =>: merge(base (hash-map "secret" secret "config" config))

defn map-portal(legacy):
  =>: map-component-base((get legacy "portal"))

defn map-registry(legacy):
  reg =: get(legacy "registry")
  registry-container =: get(reg "registry")
  controller =: get(reg "controller")
  extra-env =: concat((or (get registry-container "extraEnvVars") []) (or (get controller "extraEnvVars") []))
  base =: hash-map("image" (if registry-container (map-image (get registry-container "image")) nil) "controller" (hash-map "image" (if controller (map-image (get controller "image")) nil)) "replicas" (get reg "replicas") "nodeSelector" (get reg "nodeSelector") "tolerations" (get reg "tolerations") "affinity" (get reg "affinity") "podAnnotations" (get reg "podAnnotations") "podLabels" (get reg "podLabels") "extraEnv" extra-env)
  secret =: (if (get reg "secret") (hash-map "http_secret" (get reg "secret")) nil)
  =>: merge(base (hash-map "secret" secret))

defn map-jobservice(legacy):
  js =: get(legacy "jobservice")
  base =: map-component-base(js)
  cfg0 =: hash-map()
  cfg1 =: (if (get js "maxJobWorkers") (assoc cfg0 "max_job_workers" (get js "maxJobWorkers")) cfg0)
  cfg2 =: (if (get js "jobLoggers") (assoc cfg1 "job_loggers" (str/join "," (get js "jobLoggers"))) cfg1)
  secret =: (if (get js "secret") (hash-map "secret" (get js "secret")) nil)
  =>: merge(base (hash-map "config" (if (empty? cfg2) nil cfg2) "secret" secret))

defn map-exporter(legacy):
  exp =: get(legacy "exporter")
  base =: map-component-base(exp)
  config =: (if (or (get exp "cacheDuration") (get exp "cacheCleanInterval")) (hash-map "cache_time" (get exp "cacheDuration") "cache_clean_interval" (get exp "cacheCleanInterval")) nil)
  =>: merge(base (hash-map "enabled" true "config" config))

defn map-trivy(legacy):
  trivy =: get(legacy "trivy")
  enabled =: get(trivy "enabled")
  when enabled:
    has-detailed =: or((get trivy "vulnType") (get trivy "severity") (get trivy "ignoreUnfixed"))
    when has-detailed:
      add-warn "WARNING" "trivy" "Trivy is now a subchart." "Configure under trivy.*":
  =>: hash-map("enabled" enabled)

defn map-metrics(legacy):
  metrics =: get(legacy "metrics")
  if (get metrics "enabled"):
    then:
      sm =: get(metrics "serviceMonitor")
      =>: hash-map("serviceMonitor" (hash-map "enabled" (get sm "enabled") "labels" (get sm "additionalLabels") "interval" (get sm "interval")))
    else:
      =>: hash-map()

defn check-unsupported(legacy):
  notary =: get(legacy "notary")
  when (and notary (get notary "enabled")):
    add-warn "ERROR" "notary" "Notary is deprecated and not supported" "Migrate to Sigstore/cosign":

  chartmuseum =: get(legacy "chartmuseum")
  when (and chartmuseum (get chartmuseum "enabled")):
    add-warn "ERROR" "chartmuseum" "ChartMuseum is deprecated" "Use OCI artifact support":

  internal-tls =: get(legacy "internalTLS")
  when (and internal-tls (get internal-tls "enabled")):
    add-warn "WARNING" "internalTLS" "Internal TLS is not implemented" "Consider service mesh":

defn print-warnings():
  ws =: deref(warnings)
  when-not (empty? ws):
    level-order =: hash-map("ERROR" 0 "WARNING" 1 "INFO" 2)
    sorted =: sort-by(\(get level-order (get %1 "level")) ws)
    error-count =: count(filter(\((get %1 "level") == "ERROR") ws))
    warning-count =: count(filter(\((get %1 "level") == "WARNING") ws))
    info-count =: count(filter(\((get %1 "level") == "INFO") ws))
    warn: "\n=== Migration Report ==="
    warn: "Errors: $error-count Warnings: $warning-count Info: $info-count"
    each w sorted:
      lvl =: get(w "level")
      pth =: get(w "path")
      msg =: get(w "message")
      act =: get(w "action")
      warn: "[$lvl] $pth: $msg"
      warn: "  Action: $act"
    when (error-count > 0):
      warn: "!!! Migration has ERRORS that require manual intervention !!!"

defn remove-nils(m):
  cond:
    (map? m):
      filtered =: filter(\(not (nil? (val %1))) m)
      mapped =: map(\(vector (key %1) (remove-nils (val %1))) filtered)
      =>: into(hash-map() mapped)
    (sequential? m):
      =>: mapv(remove-nils m)
    else: m
